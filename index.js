import fs from "node:fs/promises";
import fetch from 'node-fetch';

const response = await fetch('https://www.npmjs.com/package/@citizenfx/client/file/2f83c0b9a6706e83a1b996af781fb93c14b26fac2491a91325796520377c834a');
const text = await response.text();

const reservedKeyWords = ["repeat", "end"];
const transformType = (type) => {
    const replacements = {
        "number[]": "Vector3",
        "number": "number",
        "string": "string",
        "boolean": "boolean",
        "bool": "boolean",
        "any": "number",
        "object": "table",
        "void": "nil",
    }
    for (const [key, value] of Object.entries(replacements))
        if (type.toLowerCase().includes(key))
            return value;
    return "number";
}


const getFunctionName = (line) => {
    const splitted = line.split("(");
    return splitted[0];
}

const getFunctionReturnType = (line) => {
    const splitted = line.split(":");
    const retval = splitted[splitted.length - 1].trim();
    const returnType = retval.startsWith('[')
        ? retval.replace("[", "").replace("]", "").trim().split(",")
        : retval;
    return returnType;
}
const returnTypeToString = (types) => {
    if (Array.isArray(types))
        return types.map(type => transformType(type)).join(", ");
    return transformType(types);
}

const checkForReservedKeyWords = (name) => {
    if (reservedKeyWords.includes(name))
        return "_" + name;
    return name;
}

const getFunctionParameters = (line) => {
    const splitted = line.split("(");
    const parameters = splitted[1].split(")")[0].split(",");
    if (parameters.length === 1 && parameters[0].trim() === "")
        return [];
    const paramStrings = parameters.map(param => param.trim());
    const paramsArray = paramStrings.map(param =>
        param.trim().split(":"));
    return paramsArray.map(([name, type]) => [checkForReservedKeyWords(name).replace("?", ""), type]);
}

const splitted = text.split("declare function");
const functions = splitted.map(line => line.split(";")[0].trim()).filter(line => !line.startsWith("/*"));
const functionStrings = new Map();
functions.forEach(line => {
    const params = getFunctionParameters(line)
        .map(([name, type]) => [name, transformType(type)]);
    const name = getFunctionName(line);
    const retval = getFunctionReturnType(line);
    const returnType = returnTypeToString(retval);
    functionStrings.set(name, `global function ${name}(${params.map(([name, type]) => `${name}: ${type}`).join(", ")}): ${returnType}\nend`);
});

const template = `-- Generated by https://github.com/JaRoLoz/teal-fivem-natives
global source: number -- for serverside
global record Vector3
    x: number
    y: number
    z: number
end
global function vector3(x: number, y: number, z: number): Vector3
end
global function vec3(x: number, y: number, z: number): Vector3
end
global function Wait(ms: number): nil\nend
global function CreateThread(callback: function(nil): nil): nil\nend
global function TriggerEvent(eventName: string, ...: any): nil\nend
global function AddEventHandler(eventName: string, cb: function(...:any): nil): nil\nend
global function TriggerServerEvent(eventName: string, ...: any): nil\nend
global function TriggerClientEvent(eventName: string, ...: any): nil\nend
global function RegisterNetEvent(eventName: string, cb: function(...:any): nil): nil\nend
global function SendNUIMessage(message: any): nil\nend
global function SetNuiFocus(hasFocus: boolean, hasCursor: boolean): nil\nend
global function SetNuiFocusKeepInput(keepInput: boolean): nil\nend
global function RegisterNuiCallback(cbName: string, handler: function(data: any, cb: function(any): nil): nil): nil\nend
${Array.from(functionStrings.values()).join("\n")}
`;

try {
    await fs.writeFile('native_defs.tl', template);
    console.log("File written successfully");
} catch (err) {
    console.error("Error writing file", err);
}
